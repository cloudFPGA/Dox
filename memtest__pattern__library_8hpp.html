<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<!-- import the script somewhere in the head -->
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>cloudFPGA (cF) API: repos_for_Dox/cFp_Zoo/ROLE/custom/hls/memtest/include/memtest_pattern_library.hpp File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">cloudFPGA (cF) API
   &#160;<span id="projectnumber">1.0</span>
   </div>
   <div id="projectbrief">The documentation of the source code of cloudFPGA (cF)</div>
  </td>
   <td style="padding-left: 0.5em;">
   <div id="projectbrief"><a href="https://cloudfpga.github.io/Doc">Return to the generic documentation of cloudFPGA</a></div>
   </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('memtest__pattern__library_8hpp.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">memtest_pattern_library.hpp File Reference<div class="ingroups"><a class="el" href="group__cF.html">cF</a> &raquo; <a class="el" href="group__cFp.html">cFp</a> &raquo; <a class="el" href="group__cFp__Zoo.html">cFp_Zoo</a> &raquo; <a class="el" href="group__IBMZRL.html">cF IBMZRL essentials</a> &raquo; <a class="el" href="group__Memtest.html">Memtest</a> &raquo; <a class="el" href="group__MemtestHLS.html">Memtest HLS</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>A library for memory test functionalities: sequence generation, reading, writing.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;stdio.h&gt;</code><br />
<code>#include &lt;iostream&gt;</code><br />
<code>#include &lt;hls_stream.h&gt;</code><br />
<code>#include &quot;ap_int.h&quot;</code><br />
<code>#include &lt;stdint.h&gt;</code><br />
<code>#include &quot;<a class="el" href="custom_2memtest_2languages_2cplusplus_2include_2config_8h_source.html">../../../../../HOST/custom/memtest/languages/cplusplus/include/config.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="network_8hpp_source.html">network.hpp</a>&quot;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for memtest_pattern_library.hpp:</div>
<div class="dyncontent">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="memtest__pattern__library_8hpp__incl.svg" width="100%" height="495"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
</div>
</div><div class="textblock"><div class="dynheader">
This graph shows which files directly or indirectly include this file:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="memtest__pattern__library_8hpp__dep__incl.svg" width="310" height="290"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</div>
<p><a href="memtest__pattern__library_8hpp_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga6af2c52fb78e97caa76afde8c49fddb1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MemtestHLS.html#ga6af2c52fb78e97caa76afde8c49fddb1">LOCAL_MEM_WORD_SIZE</a>&#160;&#160;&#160;512</td></tr>
<tr class="separator:ga6af2c52fb78e97caa76afde8c49fddb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga56f16521f9aeb882027d1316c192d987"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MemtestHLS.html#ga56f16521f9aeb882027d1316c192d987">LOCAL_MEM_ADDR_SIZE</a>&#160;&#160;&#160;40</td></tr>
<tr class="separator:ga56f16521f9aeb882027d1316c192d987"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e08f2fd840e4f6d503f7efd0b70e2af"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MemtestHLS.html#ga5e08f2fd840e4f6d503f7efd0b70e2af">LOCAL_MEM_ADDR_SIZE_NON_BYTE_ADDRESSABLE</a>&#160;&#160;&#160;40</td></tr>
<tr class="separator:ga5e08f2fd840e4f6d503f7efd0b70e2af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab52e53336841df56c05498bd0d0da76f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MemtestHLS.html#gab52e53336841df56c05498bd0d0da76f">LOCAL_MEM_ADDR_OFFSET</a>&#160;&#160;&#160;(<a class="el" href="group__MemtestHLS.html#ga6af2c52fb78e97caa76afde8c49fddb1">LOCAL_MEM_WORD_SIZE</a>/8)</td></tr>
<tr class="separator:gab52e53336841df56c05498bd0d0da76f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaffc354167d9f6770de1c235c9bcfa3e8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MemtestHLS.html#gaffc354167d9f6770de1c235c9bcfa3e8">LOCAL_MEM_WORD_BYTE_SIZE</a>&#160;&#160;&#160;(<a class="el" href="group__MemtestHLS.html#ga6af2c52fb78e97caa76afde8c49fddb1">LOCAL_MEM_WORD_SIZE</a>/8)</td></tr>
<tr class="separator:gaffc354167d9f6770de1c235c9bcfa3e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gafdb7e933860469fb21632f96400b1dd1"><td class="memItemLeft" align="right" valign="top">typedef ap_uint&lt; 512 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MemtestHLS.html#gafdb7e933860469fb21632f96400b1dd1">local_mem_word_t</a></td></tr>
<tr class="separator:gafdb7e933860469fb21632f96400b1dd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2071030177a0801117717eff78357f24"><td class="memItemLeft" align="right" valign="top">typedef ap_uint&lt; 40 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MemtestHLS.html#ga2071030177a0801117717eff78357f24">local_mem_addr_t</a></td></tr>
<tr class="separator:ga2071030177a0801117717eff78357f24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga457226cd68f8edca0ebb20e7b0132a14"><td class="memItemLeft" align="right" valign="top">typedef ap_uint&lt; 40 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MemtestHLS.html#ga457226cd68f8edca0ebb20e7b0132a14">local_mem_addr_non_byteaddressable_t</a></td></tr>
<tr class="separator:ga457226cd68f8edca0ebb20e7b0132a14"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gae5ddc495078f3b74e5e2bd8a753aa9da"><td class="memTemplParams" colspan="2">template&lt;typename Tin , typename Tout &gt; </td></tr>
<tr class="memitem:gae5ddc495078f3b74e5e2bd8a753aa9da"><td class="memTemplItemLeft" align="right" valign="top">Tout&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MemtestHLS.html#gae5ddc495078f3b74e5e2bd8a753aa9da">genNextFibonacciNumber</a> (Tin curr, Tin prev)</td></tr>
<tr class="separator:gae5ddc495078f3b74e5e2bd8a753aa9da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga06287c668a251d8f6f80a286561ea822"><td class="memTemplParams" colspan="2">template&lt;typename ADDR_T , unsigned int sequenceDim, typename BIGWORD_T , typename SMALLWORD_T , unsigned int smallWordDim&gt; </td></tr>
<tr class="memitem:ga06287c668a251d8f6f80a286561ea822"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MemtestHLS.html#ga06287c668a251d8f6f80a286561ea822">genFibonacciNumbers</a> (ADDR_T curr, BIGWORD_T *outBigWord)</td></tr>
<tr class="separator:ga06287c668a251d8f6f80a286561ea822"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga56cdafb7b17f861aa7455b29de2a00a4"><td class="memTemplParams" colspan="2">template&lt;typename ADDR_T , unsigned int sequenceDim, typename BIGWORD_T , typename SMALLWORD_T , unsigned int smallWordDim&gt; </td></tr>
<tr class="memitem:ga56cdafb7b17f861aa7455b29de2a00a4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MemtestHLS.html#ga56cdafb7b17f861aa7455b29de2a00a4">genXoredSequentialNumbers</a> (ADDR_T curr, BIGWORD_T *outBigWord)</td></tr>
<tr class="separator:ga56cdafb7b17f861aa7455b29de2a00a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3fc34611eb8c95906b28b1189efa6a73"><td class="memTemplParams" colspan="2">template&lt;typename ADDR_T , unsigned int sequenceDim, typename BIGWORD_T , typename SMALLWORD_T , unsigned int smallWordDim&gt; </td></tr>
<tr class="memitem:ga3fc34611eb8c95906b28b1189efa6a73"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MemtestHLS.html#ga3fc34611eb8c95906b28b1189efa6a73">genXoredSequentialNumbersSecondVersion</a> (ADDR_T curr, BIGWORD_T *outBigWord)</td></tr>
<tr class="separator:ga3fc34611eb8c95906b28b1189efa6a73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafbf8c55d3d75f79c36233a65722fbb3e"><td class="memTemplParams" colspan="2">template&lt;typename ADDR_T , typename BIGWORD_T &gt; </td></tr>
<tr class="memitem:gafbf8c55d3d75f79c36233a65722fbb3e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MemtestHLS.html#gafbf8c55d3d75f79c36233a65722fbb3e">genXoredNumbersSingleWord</a> (ADDR_T curr, BIGWORD_T *outBigWord)</td></tr>
<tr class="separator:gafbf8c55d3d75f79c36233a65722fbb3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb7b761cd133a13e7f5f9722193a6518"><td class="memTemplParams" colspan="2">template&lt;typename ADDR_T , typename BIGWORD_T &gt; </td></tr>
<tr class="memitem:gacb7b761cd133a13e7f5f9722193a6518"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MemtestHLS.html#gacb7b761cd133a13e7f5f9722193a6518">genSequentialNumbers</a> (ADDR_T curr, BIGWORD_T *outBigWord)</td></tr>
<tr class="separator:gacb7b761cd133a13e7f5f9722193a6518"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef6d60b9f93950ff7d5e0317f6008b62"><td class="memTemplParams" colspan="2">template&lt;const unsigned int max_iterations = 4000000, const unsigned int buff_dim = 16&gt; </td></tr>
<tr class="memitem:gaef6d60b9f93950ff7d5e0317f6008b62"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MemtestHLS.html#gaef6d60b9f93950ff7d5e0317f6008b62">pWRGenerateData2WriteOnStream</a> (hls::stream&lt; <a class="el" href="group__MemtestHLS.html#gafdb7e933860469fb21632f96400b1dd1">local_mem_word_t</a> &gt; &amp;sOutGeneratedData, ap_uint&lt; 32 &gt; *testCounter, <a class="el" href="group__MemtestHLS.html#ga2071030177a0801117717eff78357f24">local_mem_addr_t</a> max_addr_ut)</td></tr>
<tr class="memdesc:gaef6d60b9f93950ff7d5e0317f6008b62"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function that generate a streams of data according to function and writes them on a stream CHECK: FAULT_INJECTION define insert after the third test some faults.  <a href="group__MemtestHLS.html#gaef6d60b9f93950ff7d5e0317f6008b62">More...</a><br /></td></tr>
<tr class="separator:gaef6d60b9f93950ff7d5e0317f6008b62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5d7b65eb4ef06645dcdd9b9476be9c1c"><td class="memTemplParams" colspan="2">template&lt;typename Tcntr , const unsigned int max_iterations = 4000000, const unsigned int buff_dim = 64*2&gt; </td></tr>
<tr class="memitem:ga5d7b65eb4ef06645dcdd9b9476be9c1c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MemtestHLS.html#ga5d7b65eb4ef06645dcdd9b9476be9c1c">pWRStream2WriteMainMemory</a> (hls::stream&lt; Tcntr &gt; &amp;sOutCmd, hls::stream&lt; <a class="el" href="group__MemtestHLS.html#gafdb7e933860469fb21632f96400b1dd1">local_mem_word_t</a> &gt; &amp;sInGeneratedData, <a class="el" href="group__MemtestHLS.html#ga878d5c83781c96967a5b6adbf75f2f3d">membus_t</a> *lcl_mem, <a class="el" href="group__MemtestHLS.html#ga2071030177a0801117717eff78357f24">local_mem_addr_t</a> max_addr_ut, unsigned int burst_size)</td></tr>
<tr class="memdesc:ga5d7b65eb4ef06645dcdd9b9476be9c1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function that read a stream of data and write them in a run-time variable burst-size.  <a href="group__MemtestHLS.html#ga5d7b65eb4ef06645dcdd9b9476be9c1c">More...</a><br /></td></tr>
<tr class="separator:ga5d7b65eb4ef06645dcdd9b9476be9c1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf19e68305dae9382f688717ae580d197"><td class="memTemplParams" colspan="2">template&lt;typename Tcntr , const unsigned int max_iterations = 4000000, const unsigned int buff_dim = 64*2&gt; </td></tr>
<tr class="memitem:gaf19e68305dae9382f688717ae580d197"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MemtestHLS.html#gaf19e68305dae9382f688717ae580d197">pWriteSimplerTestMemTest</a> (hls::stream&lt; Tcntr &gt; &amp;sOutCmd, <a class="el" href="group__MemtestHLS.html#ga878d5c83781c96967a5b6adbf75f2f3d">membus_t</a> *lcl_mem, <a class="el" href="group__MemtestHLS.html#ga2071030177a0801117717eff78357f24">local_mem_addr_t</a> max_addr_ut, unsigned int burst_size)</td></tr>
<tr class="memdesc:gaf19e68305dae9382f688717ae580d197"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple version of a write memtest that write up to a given maximum address No control on the burst size or on the first faulty address.  <a href="group__MemtestHLS.html#gaf19e68305dae9382f688717ae580d197">More...</a><br /></td></tr>
<tr class="separator:gaf19e68305dae9382f688717ae580d197"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga58f4723b60536bd8498af62fe809943c"><td class="memTemplParams" colspan="2">template&lt;typename Tcntr , const unsigned int max_iterations = 4000000, const unsigned int buff_dim = 64*2&gt; </td></tr>
<tr class="memitem:ga58f4723b60536bd8498af62fe809943c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MemtestHLS.html#ga58f4723b60536bd8498af62fe809943c">pReadSimplerTestMemTest</a> (hls::stream&lt; Tcntr &gt; &amp;sOutCmd, <a class="el" href="group__MemtestHLS.html#ga878d5c83781c96967a5b6adbf75f2f3d">membus_t</a> *lcl_mem, <a class="el" href="group__MemtestHLS.html#ga2071030177a0801117717eff78357f24">local_mem_addr_t</a> max_addr_ut, unsigned int burst_size, ap_uint&lt; 32 &gt; *faulty_addresses_cntr, <a class="el" href="group__MemtestHLS.html#ga2071030177a0801117717eff78357f24">local_mem_addr_t</a> *first_faulty_address)</td></tr>
<tr class="memdesc:ga58f4723b60536bd8498af62fe809943c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple version of a read memtest that read up to a given maximum address No control on the burst size or on the first faulty address.  <a href="group__MemtestHLS.html#ga58f4723b60536bd8498af62fe809943c">More...</a><br /></td></tr>
<tr class="separator:ga58f4723b60536bd8498af62fe809943c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9a1b97bdd107f30b72244a79abb09e9a"><td class="memTemplParams" colspan="2">template&lt;typename Tcntr , const unsigned int max_iterations = 4000000, const unsigned int buff_dim = 64*2&gt; </td></tr>
<tr class="memitem:ga9a1b97bdd107f30b72244a79abb09e9a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MemtestHLS.html#ga9a1b97bdd107f30b72244a79abb09e9a">pRDRead2StreamDataVariableBurstNoMemCpy</a> (hls::stream&lt; Tcntr &gt; &amp;sOutCmd, hls::stream&lt; <a class="el" href="group__MemtestHLS.html#gafdb7e933860469fb21632f96400b1dd1">local_mem_word_t</a> &gt; &amp;sOutReadData, <a class="el" href="group__MemtestHLS.html#ga878d5c83781c96967a5b6adbf75f2f3d">membus_t</a> *lcl_mem, <a class="el" href="group__MemtestHLS.html#ga2071030177a0801117717eff78357f24">local_mem_addr_t</a> max_addr_ut, unsigned int burst_size)</td></tr>
<tr class="memdesc:ga9a1b97bdd107f30b72244a79abb09e9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a variable burst_size amount of data and output on a stream and count the cc needed just 4 transfer but without using memcpy.  <a href="group__MemtestHLS.html#ga9a1b97bdd107f30b72244a79abb09e9a">More...</a><br /></td></tr>
<tr class="separator:ga9a1b97bdd107f30b72244a79abb09e9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae8abd8a453243768a22edd5e9b8ae968"><td class="memTemplParams" colspan="2">template&lt;const unsigned int max_iterations = 4000000&gt; </td></tr>
<tr class="memitem:gae8abd8a453243768a22edd5e9b8ae968"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MemtestHLS.html#gae8abd8a453243768a22edd5e9b8ae968">pRDReadDataStreamAndProduceGold</a> (hls::stream&lt; <a class="el" href="group__MemtestHLS.html#gafdb7e933860469fb21632f96400b1dd1">local_mem_word_t</a> &gt; &amp;sInReadData, <a class="el" href="group__MemtestHLS.html#ga2071030177a0801117717eff78357f24">local_mem_addr_t</a> max_addr_ut, hls::stream&lt; <a class="el" href="group__MemtestHLS.html#gafdb7e933860469fb21632f96400b1dd1">local_mem_word_t</a> &gt; &amp;sOutReadData, hls::stream&lt; <a class="el" href="group__MemtestHLS.html#gafdb7e933860469fb21632f96400b1dd1">local_mem_word_t</a> &gt; &amp;sOutGoldData)</td></tr>
<tr class="memdesc:gae8abd8a453243768a22edd5e9b8ae968"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a data stream and produce the gold expected value.  <a href="group__MemtestHLS.html#gae8abd8a453243768a22edd5e9b8ae968">More...</a><br /></td></tr>
<tr class="separator:gae8abd8a453243768a22edd5e9b8ae968"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf30110004fb7a2c5921bbb30d0ff5e81"><td class="memTemplParams" colspan="2">template&lt;const unsigned int max_iterations = 4000000, const unsigned int buff_dim = 16&gt; </td></tr>
<tr class="memitem:gaf30110004fb7a2c5921bbb30d0ff5e81"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MemtestHLS.html#gaf30110004fb7a2c5921bbb30d0ff5e81">pRDCmpStreamsCntWordAligned</a> (<a class="el" href="group__MemtestHLS.html#ga2071030177a0801117717eff78357f24">local_mem_addr_t</a> max_addr_ut, hls::stream&lt; <a class="el" href="group__MemtestHLS.html#gafdb7e933860469fb21632f96400b1dd1">local_mem_word_t</a> &gt; &amp;sInReadData, hls::stream&lt; <a class="el" href="group__MemtestHLS.html#gafdb7e933860469fb21632f96400b1dd1">local_mem_word_t</a> &gt; &amp;sInGoldData, ap_uint&lt; 32 &gt; *faulty_addresses_cntr, <a class="el" href="group__MemtestHLS.html#ga2071030177a0801117717eff78357f24">local_mem_addr_t</a> *first_faulty_address)</td></tr>
<tr class="memdesc:gaf30110004fb7a2c5921bbb30d0ff5e81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read two streams, compare them and output the number of faults and the first faulty address.  <a href="group__MemtestHLS.html#gaf30110004fb7a2c5921bbb30d0ff5e81">More...</a><br /></td></tr>
<tr class="separator:gaf30110004fb7a2c5921bbb30d0ff5e81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafdeec7d3b1b1f6303a26bc2b8786a9a9"><td class="memTemplParams" colspan="2">template&lt;const unsigned int max_iterations = 4000000, const unsigned int unrolling_factor = ( 512 /8), const unsigned int buff_dim = 16&gt; </td></tr>
<tr class="memitem:gafdeec7d3b1b1f6303a26bc2b8786a9a9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MemtestHLS.html#gafdeec7d3b1b1f6303a26bc2b8786a9a9">pRDCompareDataStreamsCount</a> (<a class="el" href="group__MemtestHLS.html#ga2071030177a0801117717eff78357f24">local_mem_addr_t</a> max_addr_ut, hls::stream&lt; <a class="el" href="group__MemtestHLS.html#gafdb7e933860469fb21632f96400b1dd1">local_mem_word_t</a> &gt; &amp;sInReadData, hls::stream&lt; <a class="el" href="group__MemtestHLS.html#gafdb7e933860469fb21632f96400b1dd1">local_mem_word_t</a> &gt; &amp;sInGoldData, ap_uint&lt; 32 &gt; *faulty_addresses_cntr, <a class="el" href="group__MemtestHLS.html#ga2071030177a0801117717eff78357f24">local_mem_addr_t</a> *first_faulty_address)</td></tr>
<tr class="memdesc:gafdeec7d3b1b1f6303a26bc2b8786a9a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read two streams, compare them and output the number of faults and the first faulty address, but check every single byte NOT USED.  <a href="group__MemtestHLS.html#gafdeec7d3b1b1f6303a26bc2b8786a9a9">More...</a><br /></td></tr>
<tr class="separator:gafdeec7d3b1b1f6303a26bc2b8786a9a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga31d3af1fd1cde3493eaf6f3b29bb811a"><td class="memTemplParams" colspan="2">template&lt;typename Tcntr , const unsigned int max_iterations = 4000000, const unsigned int buff_dim = 64*2&gt; </td></tr>
<tr class="memitem:ga31d3af1fd1cde3493eaf6f3b29bb811a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MemtestHLS.html#ga31d3af1fd1cde3493eaf6f3b29bb811a">pRDMainMemoryRead2StreamData</a> (hls::stream&lt; Tcntr &gt; &amp;sOutCmd, hls::stream&lt; <a class="el" href="group__MemtestHLS.html#gafdb7e933860469fb21632f96400b1dd1">local_mem_word_t</a> &gt; &amp;sOutreadData, <a class="el" href="group__MemtestHLS.html#ga878d5c83781c96967a5b6adbf75f2f3d">membus_t</a> *lcl_mem, <a class="el" href="group__MemtestHLS.html#ga2071030177a0801117717eff78357f24">local_mem_addr_t</a> max_addr_ut, unsigned int burst_size)</td></tr>
<tr class="memdesc:ga31d3af1fd1cde3493eaf6f3b29bb811a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a single word of data and output on a stream and count the cc needed just 4 transfer <br  />
 NOT USED.  <a href="group__MemtestHLS.html#ga31d3af1fd1cde3493eaf6f3b29bb811a">More...</a><br /></td></tr>
<tr class="separator:ga31d3af1fd1cde3493eaf6f3b29bb811a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae47988a05f6f3f4e558d13b5b116d992"><td class="memTemplParams" colspan="2">template&lt;typename Tcntr , const unsigned int max_iterations = 4000000, const unsigned int buff_dim = 64*2&gt; </td></tr>
<tr class="memitem:gae47988a05f6f3f4e558d13b5b116d992"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MemtestHLS.html#gae47988a05f6f3f4e558d13b5b116d992">pRDRead2StreamDataVariableBurst</a> (hls::stream&lt; Tcntr &gt; &amp;sOutCmd, hls::stream&lt; <a class="el" href="group__MemtestHLS.html#gafdb7e933860469fb21632f96400b1dd1">local_mem_word_t</a> &gt; &amp;sOutreadData, <a class="el" href="group__MemtestHLS.html#ga878d5c83781c96967a5b6adbf75f2f3d">membus_t</a> *lcl_mem, <a class="el" href="group__MemtestHLS.html#ga2071030177a0801117717eff78357f24">local_mem_addr_t</a> max_addr_ut, unsigned int burst_size)</td></tr>
<tr class="memdesc:gae47988a05f6f3f4e558d13b5b116d992"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a variable burst_size amount of data and output on a stream and count the cc needed just 4 transfer <br  />
 THIS FUNCTION SUFFER FIFO OVERFLOW 4 transfer different from power of 2 numbers NOT USED.  <a href="group__MemtestHLS.html#gae47988a05f6f3f4e558d13b5b116d992">More...</a><br /></td></tr>
<tr class="separator:gae47988a05f6f3f4e558d13b5b116d992"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A library for memory test functionalities: sequence generation, reading, writing. </p>
<dl class="section author"><dt>Author</dt><dd>DCO </dd></dl>
<h2><a class="anchor" id="autotoc_md31"></a>
@date       September 2021</h2>
<p>The pattern library is a collection of functions to abstract employs different approach to generate a sequence (useful to test particular bits of the current memory word of 512 bits); the way of reading: having run-time variable (controllable) data to read/write requires different methodologies. The write currently exploit a buffer of MAX_BURST (i.e., 4096) to accumulate the data to write and then write exploitng <a class="el" href="memtest__library_8hpp.html" title="A library for some common functionalities: Network-Related Memory interaction Performance Counters.">memtest_library.hpp</a> functions. The read instead harvest the data and write to a stream, generate the gold value (based the sequence generation approach) and then compare, collecting some information on how the memory test went (how many faults, where the first and the CC needed ONLY for AXI transactions) WARNING: HLS-based memory perf counters of AXI transactions accounts for the overall time of a read, while the write is considered finished when issuing the data (while the AXI protocol considers the transaction closed when the slave answer with the ACK/BRESP)</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000003">Deprecated:</a></b></dt><dd><br  />
</dd></dl>
<hr  />
 
<p class="definition">Definition in file <a class="el" href="memtest__pattern__library_8hpp_source.html">memtest_pattern_library.hpp</a>.</p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_b7e1ac749c44ea1caea8cb543e7af8e2.html">repos_for_Dox</a></li><li class="navelem"><a class="el" href="dir_5d142b4fa6d7f5d9409cd75f2ef7494f.html">cFp_Zoo</a></li><li class="navelem"><a class="el" href="dir_372190bba8e51f711404a4d20d8d4609.html">ROLE</a></li><li class="navelem"><a class="el" href="dir_e9961d5b244581f114631536c420bc43.html">custom</a></li><li class="navelem"><a class="el" href="dir_b78b1bb98bf307aa34f3c18c58e5015e.html">hls</a></li><li class="navelem"><a class="el" href="dir_6dc731a9991b35f8e1decb21546a86ce.html">memtest</a></li><li class="navelem"><a class="el" href="dir_3b930157ed78a60a8e28ffff7dd13b85.html">include</a></li><li class="navelem"><a class="el" href="memtest__pattern__library_8hpp.html">memtest_pattern_library.hpp</a></li>
    <li class="footer">Generated on Sat Jul 15 2023 05:03:02 for cloudFPGA (cF) API by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
    <!-- add the button to toggle the theme -->
    <script>
    $(document).ready(function(){
        toggleButton = document.createElement('doxygen-awesome-dark-mode-toggle')
        toggleButton.title = "Toggle Light/Dark Mode"
        document.getElementById("MSearchBox").parentNode.appendChild(toggleButton)
    })
    </script>
</html>
